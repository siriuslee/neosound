import re

from brian import second, Quantity, units, hertz
from brian.hears import dB, dB_type
from numpy import asarray


class SoundTransform(object):
    """
    Generic sound transform. Sound transform classes are designed to enable storing and reconstructing of sound objects from transformation metadata. Basically, by storing how each sound is generated by intializing (e.g. loading or creating a sound) or transforming a parent sound object, we can reconstruct the resulting sound exactly without needing to store it.
    """

    def __init__(self, manager, derived, metadata, original=None):

        self.manager = manager
        self.derived = derived
        self.metadata = metadata
        self.original = original

    def store(self):
        """
        Store the transformation metadata for derived in the database
        :return: True if data was stored, else False
        """

        # Cannot use setdefault here because original might be None
        if "parents" not in self.metadata:
            self.metadata["parents"] = [self.original.id]
        stored = self.manager.database.store_metadata(self.derived.id, **self.metadata)

        stored = stored and self._update_children(self.metadata["parents"],
                                                  self.derived.id)

        return stored

    def _update_children(self, parents, child):

        stored = True
        for parent in parents:
            metadata = self.manager.database.get_metadata(parent)
            children = metadata.get("children", list())
            children.append(child)
            stored = stored and self.manager.database.store_metadata(parent,
                                                                     children=children)

        return stored


class InitTransform(SoundTransform):

    def store(self):
        """
        Store the transformation metadata for derived in the database
        :return: True if data was stored, else False
        """

        self.metadata.setdefault("parents", list())
        stored = self.manager.database.store_metadata(self.derived.id, **self.metadata)

        return stored

    @staticmethod
    def reconstruct(waveform, metadata, silence=False, manager=None):
        from neosound.sound import Sound

        if hasattr(waveform, "samplerate"):
            samplerate = waveform.samplerate
        else:
            samplerate = float(metadata["samplerate"]) * hertz

        if waveform is not None:
            sound = Sound(waveform, samplerate=samplerate, manager=manager)

        if silence:
            manager.logger.debug("Returning silence instead")
            return sound.to_silence()
        else:
            return sound


class LoadTransform(InitTransform):
    """
    Stores data corresponding to a file load.
    """
    @staticmethod
    def reconstruct(waveform, metadata, silence=False, manager=None):
        from neosound.sound import Sound

        if hasattr(waveform, "samplerate"):
            samplerate = waveform.samplerate
        else:
            samplerate = float(metadata["samplerate"]) * hertz

        if waveform is not None:
            sound = Sound(waveform, samplerate=samplerate, manager=manager)
        else:
            sound = Sound(metadata["filename"], manager=manager)

        if silence:
            manager.logger.debug("Returning silence instead")
            return sound.to_silence()
        else:
            return sound


class CreateTransform(InitTransform):
    """
    Stores data corresponding to a sound creation from some built-in type.
    """
    @staticmethod
    def reconstruct(waveform, metadata, silence=False, manager=None):
        from neosound.sound import Sound

        if hasattr(waveform, "samplerate"):
            samplerate = waveform.samplerate
        else:
            samplerate = float(metadata["samplerate"]) * hertz

        if waveform is not None:
            sound = Sound(waveform, samplerate=samplerate, manager=manager)
        else:
            create = getattr(Sound, metadata["sound"])
            for kw in ["sound", "type"]:
                metadata.pop(kw)

            for kw, val in metadata.iteritems():
                if not kw.endswith("_units"):
                    if "%s_units" % kw in metadata:
                        val_units = metadata.pop("%s_units" % kw)
                        val_units = eval(re.subn("[a-z]+", lambda m: "units.%s" % m.group(), val_units)[0])
                        metadata[kw] = val * val_units

            create(manager=manager, **metadata)

        if silence:
            manager.logger.debug("Returning silence instead")
            return sound.to_silence()
        else:
            manager.logger.debug("Found waveform: returning")
            return sound


class MonoTransform(SoundTransform):
    """
    Stores data corresponding to converting a multi-channel sound to mono.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        manager.logger.debug("Reconstructing mono transform")
        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)

        return sound.to_mono(read_only=True)


class ChannelTransform(SoundTransform):
    """
    Stores data corresponding to extracting a channel from a multi-channel sound.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        manager.logger.debug("Reconstructing mono transform")
        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)

        return sound.get_channel(metadata["channel"], read_only=True)


class FilterTransform(SoundTransform):
    """
    Stores data corresponding to applying a filter to a sound.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        manager.logger.debug("Reconstructing filter transform")
        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        frequency_range = [metadata["min_frequency"]*hertz,
                           metadata["max_frequency"]*hertz]

        return sound.filter(frequency_range,
                            filter_order=metadata["order"],
                            read_only=True)


class RampTransform(SoundTransform):
    """
    Stores data corresponding to applying a ramp to a sound.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        manager.logger.debug("Reconstructing ramp transform")
        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        when = metadata["when"]
        duration = metadata["duration"]*second

        return sound.ramp(when=when, duration=duration, read_only=True)


class ResampleTransform(SoundTransform):
    """
    Stores data related to resampling a sound.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = float(metadata["samplerate"]) * hertz

        manager.logger.debug("Reconstructing resample transform")
        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        new_samplerate = metadata["new_samplerate"]*hertz
        resample_type = metadata["resample_type"]

        return sound.resample(new_samplerate, resample_type=resample_type, read_only=True)


class PadTransform(SoundTransform):
    """
    Stores data related to padding a sound with zeros.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        manager.logger.debug("Reconstructing pad transform")

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        start = metadata["start_time"]*second
        duration = metadata["duration"]*second

        return sound.pad(duration, start=start, read_only=True)


class ClipTransform(SoundTransform):
    """
    Stores data about clipping a sound outside of a range.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        manager.logger.debug("Reconstructing clip transform")

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)

        return sound.clip(metadata["max_value"], metadata["min_value"],
                          read_only=True)


class SliceTransform(SoundTransform):
    """
    Stores data about slicing a segment out of a sound.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        manager.logger.debug("Reconstructing slice transform")

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        start = metadata["start_time"]*second
        stop = metadata["stop_time"]*second

        return sound.slice(start, stop, read_only=True)


class MultiplyTransform(SoundTransform):
    """
    Stores data about scaling a sound
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        manager.logger.debug("Reconstructing multiply transform")

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        level = metadata["level"]*dB

        return sound.set_level(level, read_only=True)

class AddTransform(SoundTransform):
    """
    Stores data about adding two sounds together.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        manager.logger.debug("Reconstructing add transform")

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        sound0 = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        sound1 = Sound(waveforms[1], samplerate=samplerate, manager=manager)

        return sound0.combine(sound1, read_only=True)


class SetTransform(SoundTransform):
    """
    Stores data about replacing a segment of sound with another.
    """
    @staticmethod
    def reconstruct(waveforms, metadata, manager=None):
        from neosound.sound import Sound

        manager.logger.debug("Reconstructing set transform")

        if hasattr(waveforms[0], "samplerate"):
            samplerate = waveforms[0].samplerate
        else:
            samplerate = metadata["samplerate"]*hertz

        sound = Sound(waveforms[0], samplerate=samplerate, manager=manager)
        replacement = Sound(waveforms[1], samplerate=samplerate, manager=manager)
        start = metadata["start_time"]*second
        stop = metadata["stop_time"]*second
        return sound.replace(start,
                             stop,
                             replacement,
                             read_only=True)


class ComponentTransform(SoundTransform):

    @staticmethod
    def reconstruct(waveforms, metadata, manager):

        manager.logger.debug("Reconstructing component")

        return manager.reconstruct_individual(metadata["id"], metadata["root_id"])
